#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//数据在内存中的存储

//整型家族
//浮点型家族
//构造类型 - 自定义类型
//  数组 
//  struct 结构体类型
//  enum 枚举
//  union 联合体
// 
//指针类型
// 
//空类型
//void
//函数返回类型 void test();
//函数参数 void test(void);
//指针 void* p;

//int main()
//{
//	int arr[10];//类型 int [10]
//	int arr[5];//类型 int [5]
//
//	return 0;
//}

//int main()
//{
//	int a = -10;
//	//原码
//	//10000000000000000000000000001010 - 原码
//	//11111111111111111111111111110101 - 反码 - 除符号位统统按位取反
//	//11111111111111111111111111110110 - 补码
//
//
//	return 0;
//}
//数据在内存中以2进制的形式存储
//对于整数来说：
//整数在内存中存储的二进制有3中表示形式：原码，反码，补码
//正整数：原码，反码，补码相同
// 
//负整数：原码，反码，补码要进行计算
//按照数据的数值直接写出的二进制序列就是原码
//原码的符号位不变，其他位按位取反，得到的就是反码
//反码+1，得到的就是补码
//
//整数在内存中存储的是补码 - 但好像是按16进制存储的，而且好像是倒着存的
//

//为什么内存中存的是补码而不是原码
//int main()
//{
	//1 - 1 
	//CPU 上没有减法器只有加法器，减法其实都是用加法来模拟的
	//1+(-1)
	//在原码的情况下相加
	//00000000000000000000000000000001 - 1
	//10000000000000000000000000000001 - -1
	//得
	//10000000000000000000000000000010 - -2 - 用原码算出来的有问题
	//在补码的情况下相加
	//00000000000000000000000000000001 - 1
	//11111111111111111111111111111111 - -1
	//得
	//100000000000000000000000000000000 - 多了一位，进上去
	//00000000000000000000000000000000 - 0 - 故用补码计算的结果合适
//	return 0;
//}

//大端字节序和小端字节序
//
//int main()
//{
//	int a = 0x11223344;
//
//
//	return 0;
//}
//大端字节序
//把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处
//11 22 33 44
//小端字节序
//把数据的低位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处
//44 33 22 11

//当前编译器是小端字节序

//int main()
//{
//	//写代码来判断当前机器的字节序
//	//通过判断4个字节中，第一个字节的数据，来确定大端小端
//	//如何只拿一个字节
//	int a = 1;
//	char* p = (char*)&a;//int*//括号内的是强制类型转换
//	if (*p == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//写成一个函数
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;//int*//括号内的是强制类型转换
//	if (*p == 1)
//	{
//		return 1;
//	}
//	else
//	{
//		return 0;
//	}
//}

//简化函数
//int check_sys()
//{
//	int a = 1;
//	char* p = (char*)&a;//int*//括号内的是强制类型转换
//	return *p;//返回1表示小端，返回0表示大端
//}
//
//int main()
//{
//	int ret = check_sys();
//	if (ret == 1)
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}


//一些题目

//输出什么
//int main()
//{
//	char a = -1;
//	//内存中放的补码
//	//10000000000000000000000000000001 - 原码
//	//11111111111111111111111111111110 - 反码
//	//11111111111111111111111111111111 - 补码
//	//11111111 - a - a中能放8个bit位
//	//11111111111111111111111111111111 - 整型提升
//	//
//	signed char b = -1;
//	//11111111 - b
//	//11111111111111111111111111111111 - 整型提升
//
//	unsigned char c = -1;
//	//11111111 - c - 无符号位整型提升补0
//	//00000000000000000000000011111111 - 整型提升
//
//	printf("a = %d b = %d c = %d", a, b, c);//打印%d，需要整型提升
//	//-1 -1
//
//	return 0;
//}
//补充：
//1.char 到底是signed char还是unsigned char？
//C语言标准并没有规定，取决于编译器
//
//int 是 signed int
//short 是 signed short
//

//下面程序的输出结果是？
//第2题
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000 - 原码 2^7=128
//	//11111111111111111111111101111111 - 反码
//	//11111111111111111111111110000000 - 补码
//	//10000000 - a
//	//11111111111111111111111110000000 - 整型提升
//	//%u - 无符号整数，没有符号位的概念，原反补都是一样的
//
//	printf("%u\n", a);//%u - 无符号整数//%d - 就能的到正确的-128
//	return 0;
//	
//}

//第3题
//int main()
//{
//	char a = 128;
//	//00000000000000000000000010000000 - 原码 2^7=128
//	//01111111111111111111111101111111 - 反码
//	//01111111111111111111111110000000 - 补码
//	//10000000 - a
//	//11111111111111111111111110000000 - 整型提升
//	//同上，因为整型提升的原因，输出的结果和上一题相同
//	printf("%u\n", a);
//
//	return 0;
//}

//
//char类型变量的取值范围
//

//第4题
//int main()
//{
//	int i = -20;
//	//10000000000000000000000000010100 - 原码
//	//11111111111111111111111111101011 - 反码
//	//11111111111111111111111111101100 - 补码
//	//
//	unsigned int j = 10;
//	//10000000000000000000000000001010 - 原、反、补
//
//	printf("%d\n", i + j);//类型发生转换
//	//11111111111111111111111111110110 - 补码
//	//11111111111111111111111111110101 - 减1
//	//10000000000000000000000000001010 - 原码 - -10
//	//
//
//	return 0;
//}

//第5题
//int main()
//{
//	unsigned int i;//无符号位，所有的数字都是有效的
//	for (i = 9; i >= 0; i--)//判断条件恒成立 - 死循环
//	{
//		printf("%u\n", i);//%u 按无符号整型打印
//	}
//
//	return 0;
//}

//第6题
//#include<string.h>
//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	//128+127=255
//	//-1 -2 -3 ... -127 -128 127 126 125 .. 3 2 1 0| -1 -2 .. -127 -128 127 ...
//	//巧记口诀（学生提供）：
//	//超出范围的数据如果是正数，则减去256.
//	//超出范围的数据如果是负数，则加上256.
//	printf("%d", strlen(a));//找到'\0' - 0,在0之前出现多少个元素，长度就是几
//
//	return 0;
//}

//第7题
unsigned char i = 0;//无符号字符型0-255
int main()
{
	for (i = 0; i <= 255; i++)//i最大就是255，i会从0重新开始
	{
		printf("hello world\n");
	}

	return 0;
}